/-
Copyright (c) 2025 Side-by-Side Blueprint Authors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
-/
import SBSBlueprint.Genre
import SBSBlueprint.Manifest

import Verso.Doc
import Verso.Doc.Html
import Verso.Output.Html

/-!
# Rendering for SBSBlueprint Hooks

This module provides HTML rendering functions for blueprint hook blocks. The hooks
(`leanNode`, `paperStatement`, etc.) store labels that reference nodes in the
manifest.json file generated by Dress.

## Rendering Context

The rendering functions need access to:
1. The manifest for looking up node URLs and status
2. The artifact directory for loading pre-rendered HTML
3. Configuration options (base URL, etc.)

## HTML Structure

The generated HTML follows the blueprint CSS conventions:
- `.sbs-container` - Main container for side-by-side displays
- `.sbs-latex-column` - Left column with LaTeX content
- `.sbs-lean-column` - Right column with Lean code
- `.theorem_thmwrapper`, `.definition_thmwrapper` - Environment wrappers
- `.status-dot` - Status indicator circles

## Artifact Loading

Pre-rendered artifacts are loaded from `.lake/build/dressed/{Module}/{label}/`:
- `decl.html` - Pre-rendered Lean code with syntax highlighting
- `decl.tex` - LaTeX source (for reference)
- `decl.json` - Metadata (status, declaration names, etc.)
- `decl.hovers.json` - Hover data for tooltips

-/

namespace Verso.Genre.SBSBlueprint.Render

open Lean (Name Json ToJson FromJson)
open Verso Doc Output Html
open Verso.Genre.SBSBlueprint
open Verso.Genre.SBSBlueprint.Manifest

/-!
## Rendering Context

Configuration for rendering, including manifest access and base paths.
-/

/--
Context for rendering blueprint content.
-/
structure RenderContext where
  /-- The loaded manifest (if available) -/
  manifest : Option BlueprintManifest := none
  /-- Base URL for the site -/
  baseUrl : String := "/"
  /-- Path to the artifact directory -/
  artifactDir : System.FilePath := ".lake/build/dressed"
  /-- Whether we're rendering for paper mode -/
  paperMode : Bool := false
  /-- Base URL for paper links back to blueprint -/
  blueprintBaseUrl : Option String := none
  deriving Inhabited

/--
Default render context.
-/
def defaultContext : RenderContext := {}

/-!
## Helper Functions
-/

/--
Escape HTML special characters.
-/
def escapeHtml (s : String) : String :=
  s.replace "&" "&amp;"
   |>.replace "<" "&lt;"
   |>.replace ">" "&gt;"
   |>.replace "\"" "&quot;"
   |>.replace "'" "&#39;"

/--
Normalize a label for use as an HTML ID (replace colons with hyphens).
-/
def normalizeId (label : String) : String :=
  label.replace ":" "-"

/--
Get the CSS color for a node status.
-/
def statusColor : NodeStatus → String
  | .notReady => "#F4A460"     -- Sandy Brown
  | .ready => "#20B2AA"        -- Light Sea Green
  | .sorry => "#8B0000"        -- Dark Red
  | .proven => "#90EE90"       -- Light Green
  | .fullyProven => "#228B22"  -- Forest Green
  | .mathlibReady => "#87CEEB" -- Light Blue

/--
Get the display name for a node status.
-/
def statusDisplayName : NodeStatus → String
  | .notReady => "Not Ready"
  | .ready => "Ready"
  | .sorry => "Has Sorry"
  | .proven => "Proven"
  | .fullyProven => "Fully Proven"
  | .mathlibReady => "Mathlib Ready"

/--
Get the CSS class for a node status.
-/
def statusCssClass : NodeStatus → String
  | .notReady => "status-not-ready"
  | .ready => "status-ready"
  | .sorry => "status-sorry"
  | .proven => "status-proven"
  | .fullyProven => "status-fully-proven"
  | .mathlibReady => "status-mathlib-ready"

/--
Capitalize the first letter of a string.
-/
def capitalize (s : String) : String :=
  match s.toList with
  | [] => s
  | c :: cs => String.ofList (c.toUpper :: cs)

/-!
## Artifact Loading

Functions for loading pre-rendered content from the artifact directory.
-/

/--
Artifact data loaded from the dressed directory.
-/
structure ArtifactData where
  /-- Pre-rendered signature HTML -/
  signatureHtml : Option String := none
  /-- Pre-rendered proof body HTML -/
  proofBodyHtml : Option String := none
  /-- Hover data JSON for tooltips -/
  hoverData : Option String := none
  /-- Node status from metadata -/
  status : NodeStatus := .notReady
  /-- Environment type (theorem, lemma, definition, etc.) -/
  envType : String := "theorem"
  /-- Display label/number -/
  displayLabel : Option String := none
  /-- Declaration names -/
  declNames : Array String := #[]
  deriving Repr, Inhabited

/--
Normalize a label for filesystem lookup (replace `:` with `-`).
This mirrors Dress.Paths.sanitizeLabel.
-/
def sanitizeLabel (label : String) : String :=
  label.replace ":" "-"

/--
Search for an artifact directory by label under the artifact base directory.
Returns the path to the artifact directory if found.

Artifacts are stored at `.lake/build/dressed/{ModulePath}/{sanitized-label}/`.
Since we don't know the module path, we search using a worklist approach.
-/
def findArtifactDir (baseDir : System.FilePath) (label : String) : IO (Option System.FilePath) := do
  let sanitized := sanitizeLabel label
  if !(← baseDir.pathExists) then return none

  -- Use a worklist approach with depth limit to avoid termination issues
  let maxDepth := 10
  let mut worklist : Array (System.FilePath × Nat) := #[(baseDir, 0)]
  let mut result : Option System.FilePath := none

  while h : worklist.size > 0 do
    let (dir, depth) := worklist[0]'(Nat.zero_lt_of_lt h)
    worklist := worklist.eraseIdx 0

    if depth > maxDepth then continue

    let entries ← dir.readDir
    for entry in entries do
      if ← entry.path.isDir then
        -- Check if this directory name matches our sanitized label
        if entry.fileName == sanitized then
          -- Verify it contains decl.json
          let jsonPath := entry.path / "decl.json"
          if ← jsonPath.pathExists then
            result := some entry.path
            worklist := #[]  -- Clear worklist to exit
            break
        -- Add subdirectory to worklist
        worklist := worklist.push (entry.path, depth + 1)

  return result

/--
Parse artifact JSON metadata.
-/
structure ArtifactJson where
  name : String := ""
  label : String := ""
  -- highlighting is a complex structure we don't need to fully parse
  deriving Repr, Inhabited

open Lean in
instance : FromJson ArtifactJson where
  fromJson? json := do
    let name := (json.getObjValAs? String "name").toOption.getD ""
    let label := (json.getObjValAs? String "label").toOption.getD ""
    pure { name, label }

/--
Try to load artifact data for a given label.
Returns default data if the artifact doesn't exist.

Searches for artifacts under ctx.artifactDir (default: `.lake/build/dressed/`).
-/
def loadArtifact (ctx : RenderContext) (label : String) : IO ArtifactData := do
  -- Find the artifact directory
  let artifactDir? ← findArtifactDir ctx.artifactDir label
  match artifactDir? with
  | none =>
    -- Artifact not found - return default
    return { status := .notReady }
  | some artifactDir =>
    -- Read decl.html for rendered code
    let htmlPath := artifactDir / "decl.html"
    let signatureHtml ← if ← htmlPath.pathExists then
      some <$> IO.FS.readFile htmlPath
    else
      pure none

    -- Read decl.hovers.json for hover data (optional)
    let hoversPath := artifactDir / "decl.hovers.json"
    let hoverData ← if ← hoversPath.pathExists then
      some <$> IO.FS.readFile hoversPath
    else
      pure none

    -- Read decl.json for metadata
    let jsonPath := artifactDir / "decl.json"
    let metadata ← if ← jsonPath.pathExists then
      let content ← IO.FS.readFile jsonPath
      match Lean.Json.parse content with
      | .ok json =>
        match Lean.FromJson.fromJson? (α := ArtifactJson) json with
        | .ok m => pure (some m)
        | .error _ => pure none
      | .error _ => pure none
    else
      pure none

    -- Look up status from manifest if available
    let status := match ctx.manifest.bind (·.findNode? label) with
      | some _nodeInfo =>
        -- TODO: The manifest currently doesn't store status per node
        -- For now, we infer based on whether we have Lean code
        if signatureHtml.isSome then .proven else .notReady
      | none => .notReady

    -- Extract declaration name for fallback display
    let declNames := match metadata with
      | some m => if m.name.isEmpty then #[] else #[m.name]
      | none => #[]

    return {
      signatureHtml
      proofBodyHtml := none  -- Not currently separated in artifacts
      hoverData
      status
      envType := "theorem"  -- Default; could be enhanced with more metadata
      displayLabel := some label
      declNames
    }

/-!
## Status Dot Rendering
-/

/--
Render a status indicator dot.
-/
def renderStatusDot (status : NodeStatus) (cssClass : String := "status-dot") : Html :=
  .tag "span" #[
    ("class", cssClass),
    ("style", s!"background-color: {statusColor status}"),
    ("title", s!"Status: {statusDisplayName status}")
  ] Html.empty

/-!
## Missing Node Placeholder
-/

/--
Render a placeholder for a missing node.
-/
def renderMissingNode (label : String) : Html :=
  .tag "div" #[
    ("class", "sbs-missing-node"),
    ("id", normalizeId label)
  ] (.tag "p" #[("class", "warning")] (
    .text true s!"Node '{label}' not found in manifest. Run the blueprint build to generate artifacts."
  ))

/-!
## Side-by-Side Rendering
-/

/--
Render the LaTeX column (left side) of a side-by-side display.
-/
def renderLatexColumn
    (envType : String)
    (displayLabel : String)
    (status : NodeStatus)
    (statementHtml : String)
    (proofHtml : Option String := none) : Html :=
  let heading := .tag "div" #[("class", s!"{envType}_thmheading")] (
    .seq #[
      .tag "span" #[("class", s!"{envType}_thmcaption")] (.text true (capitalize envType)),
      .tag "span" #[("class", s!"{envType}_thmlabel")] (.text true displayLabel),
      .tag "div" #[("class", s!"thm_header_extras {statusCssClass status}")] (
        renderStatusDot status "status-dot header-status-dot"
      )
    ]
  )

  let statement := .tag "div" #[("class", s!"{envType}_thmcontent")] (
    .tag "p" #[] (.text false statementHtml)  -- false = don't escape, already HTML
  )

  let proofToggle := match proofHtml with
    | none => Html.empty
    | some proof =>
      .tag "div" #[("class", "proof_wrapper proof_inline")] (
        .seq #[
          .tag "div" #[("class", "proof_heading")] (
            .seq #[
              .tag "span" #[("class", "proof_caption")] (.text true "Proof"),
              .tag "span" #[("class", "expand-proof")] (.text true "[show]")
            ]
          ),
          .tag "div" #[("class", "proof_content")] (
            .tag "p" #[] (.text false proof)
          )
        ]
      )

  .tag "div" #[("class", "sbs-latex-column")] (
    .seq #[heading, statement, proofToggle]
  )

/--
Render the Lean column (right side) of a side-by-side display.
-/
def renderLeanColumn
    (signatureHtml : Option String)
    (proofBodyHtml : Option String)
    (hoverData : Option String := none)
    (fallbackNames : Array String := #[]) : Html :=
  let codeContent := match signatureHtml, proofBodyHtml with
    | some sig, some proof =>
      .seq #[
        .tag "code" #[("class", "hl lean lean-signature")] (.text false sig),
        .tag "code" #[("class", "hl lean lean-proof-body")] (.text false proof)
      ]
    | some sig, none =>
      .tag "code" #[("class", "hl lean lean-signature")] (.text false sig)
    | none, some proof =>
      .tag "code" #[("class", "hl lean lean-proof-body")] (.text false proof)
    | none, none =>
      let names := String.intercalate ", " fallbackNames.toList
      if names.isEmpty then
        .tag "code" #[("class", "hl lean")] (.text true "-- No Lean code available")
      else
        .tag "code" #[("class", "hl lean")] (.text true s!"-- See: {names}")

  let hoverAttr := match hoverData with
    | some json => #[("data-lean-hovers", escapeHtml json)]
    | none => #[]

  let preAttrs := #[("class", "lean-code hl lean")] ++ hoverAttr

  .tag "div" #[("class", "sbs-lean-column")] (
    .tag "pre" preAttrs codeContent
  )

/--
Render a complete side-by-side display.
-/
def renderSideBySide
    (label : String)
    (envType : String)
    (displayLabel : String)
    (status : NodeStatus)
    (statementHtml : String)
    (proofHtml : Option String := none)
    (signatureHtml : Option String := none)
    (proofBodyHtml : Option String := none)
    (hoverData : Option String := none)
    (declNames : Array String := #[]) : Html :=
  let containerClass := s!"{envType}_thmwrapper sbs-container theorem-style-{envType}"
  let latexCol := renderLatexColumn envType displayLabel status statementHtml proofHtml
  let leanCol := renderLeanColumn signatureHtml proofBodyHtml hoverData declNames

  .tag "div" #[
    ("id", normalizeId label),
    ("class", containerClass)
  ] (.seq #[latexCol, leanCol])

/-!
## Paper Mode Rendering

For paper mode, we render with slightly different styling and include
links back to the blueprint.
-/

/--
Render a paper-style LaTeX column with verification badge.
-/
def renderPaperLatexColumn
    (envType : String)
    (displayLabel : String)
    (status : NodeStatus)
    (statementHtml : String)
    (proofHtml : Option String := none)
    (blueprintUrl : Option String := none) : Html :=
  let blueprintLink := match blueprintUrl with
    | some url => .tag "a" #[("class", "blueprint-link"), ("href", escapeHtml url)] (.text true "[blueprint]")
    | none => Html.empty

  let heading := .tag "div" #[("class", "paper-theorem-header")] (
    .seq #[
      .tag "span" #[("class", "paper-theorem-type")] (
        .text true s!"{capitalize envType} {displayLabel}"
      ),
      renderStatusDot status "status-dot paper-status-dot",
      blueprintLink
    ]
  )

  let statement := .tag "div" #[("class", s!"{envType}_thmcontent")] (
    .tag "p" #[] (.text false statementHtml)
  )

  let proofToggle := match proofHtml with
    | none => Html.empty
    | some proof =>
      .tag "div" #[("class", "proof_wrapper proof_inline")] (
        .seq #[
          .tag "div" #[("class", "proof_heading")] (
            .seq #[
              .tag "span" #[("class", "proof_caption")] (.text true "Proof"),
              .tag "span" #[("class", "expand-proof")] (.text true "[show]")
            ]
          ),
          .tag "div" #[("class", "proof_content")] (
            .tag "p" #[] (.text false proof)
          )
        ]
      )

  .tag "div" #[("class", "sbs-latex-column")] (
    .seq #[heading, statement, proofToggle]
  )

/--
Render a paper-style display (typically without Lean code column).
-/
def renderPaperDisplay
    (label : String)
    (envType : String)
    (displayLabel : String)
    (status : NodeStatus)
    (statementHtml : String)
    (proofHtml : Option String := none)
    (blueprintUrl : Option String := none) : Html :=
  let containerClass := s!"paper-theorem paper-{envType}"
  let latexCol := renderPaperLatexColumn envType displayLabel status statementHtml proofHtml blueprintUrl

  .tag "div" #[
    ("id", normalizeId label),
    ("class", containerClass)
  ] latexCol

/-!
## Hook Rendering Functions

Main entry points for rendering hook blocks.
-/

/--
Render a `leanNode` hook - full side-by-side display.

This is the primary hook for displaying blueprint nodes with both
LaTeX and Lean content side by side.
-/
def renderLeanNode (ctx : RenderContext) (label : String) : IO Html := do
  -- Check if node exists in manifest
  match ctx.manifest.bind (·.findNode? label) with
  | none => pure (renderMissingNode label)
  | some _nodeInfo =>
    -- Load artifact data
    let artifact ← loadArtifact ctx label
    -- For now, render a placeholder - actual content comes from artifacts
    pure (renderSideBySide
      label
      artifact.envType
      (artifact.displayLabel.getD label)
      artifact.status
      "(LaTeX statement placeholder - load from artifact)"
      none  -- proofHtml
      artifact.signatureHtml
      artifact.proofBodyHtml
      artifact.hoverData
      artifact.declNames)

/--
Render a `paperStatement` hook - statement with Lean signature only.

Shows the LaTeX statement and Lean type signature, but no proofs.
-/
def renderPaperStatement (ctx : RenderContext) (label : String) : IO Html := do
  match ctx.manifest.bind (·.findNode? label) with
  | none => pure (renderMissingNode label)
  | some _nodeInfo =>
    let artifact ← loadArtifact ctx label
    let blueprintUrl := ctx.blueprintBaseUrl.map (· ++ "#" ++ normalizeId label)
    pure (renderPaperDisplay
      label
      artifact.envType
      (artifact.displayLabel.getD label)
      artifact.status
      "(LaTeX statement placeholder)"
      none  -- No proof in statement mode
      blueprintUrl)

/--
Render a `paperFull` hook - statement + proof + full Lean code.

Equivalent to `leanNode` but may have different styling for paper context.
-/
def renderPaperFull (ctx : RenderContext) (label : String) : IO Html := do
  match ctx.manifest.bind (·.findNode? label) with
  | none => pure (renderMissingNode label)
  | some _nodeInfo =>
    let artifact ← loadArtifact ctx label
    let blueprintUrl := ctx.blueprintBaseUrl.map (· ++ "#" ++ normalizeId label)
    if ctx.paperMode then
      -- Paper mode: simpler display
      pure (renderPaperDisplay
        label
        artifact.envType
        (artifact.displayLabel.getD label)
        artifact.status
        "(LaTeX statement placeholder)"
        (some "(LaTeX proof placeholder)")
        blueprintUrl)
    else
      -- Blueprint mode: full side-by-side
      pure (renderSideBySide
        label
        artifact.envType
        (artifact.displayLabel.getD label)
        artifact.status
        "(LaTeX statement placeholder)"
        (some "(LaTeX proof placeholder)")
        artifact.signatureHtml
        artifact.proofBodyHtml
        artifact.hoverData
        artifact.declNames)

/--
Render a `paperProof` hook - proof content only.

Shows only the proof without the statement. Useful when the statement
has already been shown elsewhere.
-/
def renderPaperProof (ctx : RenderContext) (label : String) : IO Html := do
  match ctx.manifest.bind (·.findNode? label) with
  | none => pure (renderMissingNode label)
  | some _nodeInfo =>
    let artifact ← loadArtifact ctx label
    -- Render just the proof block
    let proofContent := .tag "div" #[("class", "proof_wrapper")] (
      .seq #[
        .tag "div" #[("class", "proof_heading")] (
          .tag "span" #[("class", "proof_caption")] (.text true "Proof")
        ),
        .tag "div" #[("class", "proof_content")] (
          .tag "p" #[] (.text true "(LaTeX proof placeholder)")
        )
      ]
    )
    let leanProof := match artifact.proofBodyHtml with
      | some html => .tag "pre" #[("class", "lean-code hl lean")] (
          .tag "code" #[("class", "hl lean lean-proof-body")] (.text false html)
        )
      | none => Html.empty

    pure (.tag "div" #[
      ("id", normalizeId label ++ "-proof"),
      ("class", "proof-only-container")
    ] (.seq #[proofContent, leanProof]))

/--
Render a `leanModule` hook - all nodes from a module.

Expands to display all blueprint nodes from the specified Lean module.
-/
def renderLeanModule (ctx : RenderContext) (moduleName : String) : IO Html := do
  match ctx.manifest with
  | none =>
    pure (.tag "div" #[("class", "lean-module-placeholder")] (
      .tag "p" #[("class", "warning")] (
        .text true s!"Module '{moduleName}' placeholder - manifest not loaded"
      )
    ))
  | some manifest =>
    -- Find all nodes from this module
    let nodes := manifest.findNodesByModule moduleName
    if nodes.isEmpty then
      pure (.tag "div" #[("class", "lean-module-placeholder")] (
        .tag "p" #[("class", "info")] (
          .text true s!"No nodes found for module '{moduleName}'"
        )
      ))
    else
      -- Render each node
      let mut htmls : Array Html := #[]
      for node in nodes do
        let nodeHtml ← renderLeanNode ctx node.id
        htmls := htmls.push nodeHtml
      pure (.tag "div" #[
        ("class", "lean-module-container"),
        ("data-module", moduleName)
      ] (.seq htmls))

/-!
## GenreHtml Integration

These functions integrate with the GenreHtml instance to provide
actual rendering for hook blocks.
-/

/--
Render a block extension to HTML.

This is called by the GenreHtml instance for each BlockExt.
-/
def renderBlockExt (ctx : RenderContext) (ext : BlockExt) : IO Html := do
  match ext with
  | .highlightedCode _opts highlighted =>
    -- Render highlighted code block
    -- For now, simple placeholder - full implementation would use SubVerso
    pure (.tag "pre" #[("class", "lean-code")] (
      .tag "code" #[("class", "hl lean")] (.text true s!"(highlighted code: {repr highlighted})")
    ))

  | .sideBySide label _latexContent leanCode status =>
    -- Direct side-by-side content (not a hook)
    -- Note: latexContent is already Html; in full implementation would serialize it
    let leanHtml := match leanCode with
      | some _hl => "(Lean code)"  -- Would render highlighted code
      | none => ""
    pure (renderSideBySide
      label
      "theorem"
      label
      status
      "(LaTeX content)"  -- Placeholder until Html serialization is implemented
      none
      (if leanHtml.isEmpty then none else some leanHtml)
      none
      none
      #[])

  | .theoremEnv kind label title statement proof =>
    -- Theorem environment
    let displayLabel := title.getD label
    pure (.tag "div" #[
      ("class", s!"{kind}_thmwrapper theorem-style-{kind}"),
      ("id", normalizeId label)
    ] (.seq #[
      .tag "div" #[("class", s!"{kind}_thmheading")] (
        .seq #[
          .tag "span" #[("class", s!"{kind}_thmcaption")] (.text true (capitalize kind)),
          .tag "span" #[("class", s!"{kind}_thmlabel")] (.text true displayLabel)
        ]
      ),
      .tag "div" #[("class", s!"{kind}_thmcontent")] statement,
      match proof with
      | some p => .tag "div" #[("class", "proof")] p
      | none => Html.empty
    ]))

  | .proofBlock content =>
    pure (.tag "div" #[("class", "proof_wrapper")] (
      .seq #[
        .tag "div" #[("class", "proof_heading")] (
          .tag "span" #[("class", "proof_caption")] (.text true "Proof")
        ),
        .tag "div" #[("class", "proof_content")] content
      ]
    ))

  | .htmlDiv classes =>
    -- Just a div wrapper - content handled by caller
    pure (.tag "div" #[("class", classes)] Html.empty)

  | .leanNode label =>
    renderLeanNode ctx label

  | .paperStatement label =>
    renderPaperStatement ctx label

  | .paperFull label =>
    renderPaperFull ctx label

  | .paperProof label =>
    renderPaperProof ctx label

  | .leanModule moduleName =>
    renderLeanModule ctx moduleName

/--
Render an inline extension to HTML.
-/
def renderInlineExt (ctx : RenderContext) (ext : InlineExt) (content : Html) : IO Html := do
  match ext with
  | .highlightedCode _opts _highlighted =>
    pure (.tag "code" #[("class", "lean-inline hl lean")] (.text true "(inline code)"))

  | .nodeRef label resolvedUrl =>
    let url := resolvedUrl.getD (ctx.baseUrl ++ "#" ++ normalizeId label)
    pure (.tag "a" #[("href", url), ("class", "node-ref")] content)

  | .statusDot status =>
    pure (renderStatusDot status)

  | .leanDocLink declName url =>
    let href := url.getD s!"#decl-{declName}"
    pure (.tag "a" #[("href", href), ("class", "lean-doc-link")] content)

  | .htmlSpan classes =>
    pure (.tag "span" #[("class", classes)] content)

end Verso.Genre.SBSBlueprint.Render

/-!
## GenreHtml Instance

The GenreHtml instance for SBSBlueprint uses a ReaderT monad to access
the RenderContext, which provides manifest data and artifact paths.
-/

namespace Verso.Genre.SBSBlueprint

section GenreHtmlInstance

open Verso.Output Html
open Verso.Doc.Html
open Verso.Genre.SBSBlueprint.Render

/--
The monad for HTML rendering with access to RenderContext.
-/
abbrev RenderM := ReaderT RenderContext IO

/--
Lift an IO action that needs RenderContext into HtmlT.
-/
def liftRenderIO (action : RenderContext → IO α) : HtmlT SBSBlueprint RenderM α := do
  -- Access the RenderContext by lifting through the monad stack
  -- HtmlT g m = ReaderT (HtmlT.Context g m) (StateT _ m)
  -- m = ReaderT RenderContext IO
  -- So we need to lift from m to access the reader
  let ctx ← (readThe RenderContext : RenderM RenderContext)
  action ctx

instance : GenreHtml SBSBlueprint RenderM where
  part _partHtml _metadata _part := do
    -- Default part rendering - returning Html.empty triggers default behavior
    pure Html.empty

  block _inlineHtml goBlock ext content := do
    match ext with
    | .highlightedCode _opts _highlighted =>
      -- TODO: Implement proper highlighted code rendering using SubVerso
      pure {{ <pre class="lean-code hl lean">"(highlighted code)"</pre> }}

    | .sideBySide label _latexContent leanCode status =>
      -- Direct side-by-side content (pre-constructed, not a hook)
      let leanHtml := match leanCode with
        | some _hl => some "(Lean code)"  -- Would render highlighted code
        | none => none
      pure (renderSideBySide
        label
        "theorem"
        label
        status
        "(LaTeX content)"  -- latexContent is already Html
        none
        leanHtml
        none
        none
        #[])

    | .theoremEnv kind label title statement proof =>
      -- Theorem environment wrapper
      let displayLabel := title.getD label
      pure (.tag "div" #[
        ("class", s!"{kind}_thmwrapper theorem-style-{kind}"),
        ("id", normalizeId label)
      ] (.seq #[
        .tag "div" #[("class", s!"{kind}_thmheading")] (
          .seq #[
            .tag "span" #[("class", s!"{kind}_thmcaption")] (.text true (capitalize kind)),
            .tag "span" #[("class", s!"{kind}_thmlabel")] (.text true displayLabel)
          ]
        ),
        .tag "div" #[("class", s!"{kind}_thmcontent")] statement,
        match proof with
        | some p => .tag "div" #[("class", "proof")] p
        | none => Html.empty
      ]))

    | .proofBlock contentHtml =>
      pure (.tag "div" #[("class", "proof_wrapper")] (
        .seq #[
          .tag "div" #[("class", "proof_heading")] (
            .tag "span" #[("class", "proof_caption")] (.text true "Proof")
          ),
          .tag "div" #[("class", "proof_content")] contentHtml
        ]
      ))

    | .htmlDiv classes =>
      -- Div wrapper - render children
      let children ← content.mapM goBlock
      pure (.tag "div" #[("class", classes)] (.seq children))

    | .leanNode label =>
      liftRenderIO fun ctx => renderLeanNode ctx label

    | .paperStatement label =>
      liftRenderIO fun ctx => renderPaperStatement ctx label

    | .paperFull label =>
      liftRenderIO fun ctx => renderPaperFull ctx label

    | .paperProof label =>
      liftRenderIO fun ctx => renderPaperProof ctx label

    | .leanModule moduleName =>
      liftRenderIO fun ctx => renderLeanModule ctx moduleName

  inline goInline ext content := do
    let renderedContent ← content.mapM goInline
    let contentHtml := Html.seq renderedContent
    match ext with
    | .highlightedCode _opts _highlighted =>
      -- TODO: Implement proper inline highlighted code
      pure {{ <code class="lean-inline hl lean">"(inline code)"</code> }}

    | .nodeRef label resolvedUrl =>
      liftRenderIO fun ctx =>
        let url := resolvedUrl.getD (ctx.baseUrl ++ "#" ++ normalizeId label)
        pure (.tag "a" #[("href", url), ("class", "node-ref")] contentHtml)

    | .statusDot status =>
      pure (renderStatusDot status)

    | .leanDocLink declName url =>
      let href := url.getD s!"#decl-{declName}"
      pure (.tag "a" #[("href", href), ("class", "lean-doc-link")] contentHtml)

    | .htmlSpan classes =>
      pure (.tag "span" #[("class", classes)] contentHtml)

end GenreHtmlInstance

end Verso.Genre.SBSBlueprint
