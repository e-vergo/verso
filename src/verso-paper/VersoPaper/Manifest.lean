/-
Copyright (c) 2025 Eric Vergo. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Eric Vergo
-/
import Lean.Data.Json.FromToJson
import Lean.Data.Json.Parser

/-!
# Manifest Types for VersoPaper

This module defines the data structures for loading blueprint node data from manifest.json.
The manifest is generated by Dress during the build process and contains all the pre-computed
artifacts needed for paper generation.
-/

namespace VersoPaper.Manifest

open Lean (Json ToJson FromJson)

/--
A node from the blueprint manifest representing a formal declaration.
Contains pre-rendered HTML for statement, proof, and Lean code, along with metadata.
-/
structure Node where
  /-- Unique identifier for this node (e.g., "thm:main") -/
  label : String
  /-- Human-readable title for display -/
  title : Option String := none
  /-- Environment type: "theorem", "lemma", "definition", etc. -/
  envType : String := "theorem"
  /-- Status: "notReady", "ready", "sorry", "proven", "fullyProven", "mathlibReady" -/
  status : String := "notReady"
  /-- Pre-rendered LaTeX statement HTML -/
  statementHtml : String := ""
  /-- Pre-rendered LaTeX proof HTML -/
  proofHtml : Option String := none
  /-- Pre-rendered Lean signature HTML with syntax highlighting -/
  signatureHtml : Option String := none
  /-- Pre-rendered Lean proof body HTML with syntax highlighting -/
  proofBodyHtml : Option String := none
  /-- Lean declaration names (may include multiple for composite declarations) -/
  declNames : Array String := #[]
  /-- Module where this declaration is defined -/
  moduleName : String := ""
  /-- Labels of nodes this node depends on -/
  uses : Array String := #[]
  /-- URL to the blueprint page for this node -/
  url : String := ""
  deriving Repr, BEq, Inhabited

instance : ToJson Node where
  toJson n := Json.mkObj [
    ("label", ToJson.toJson n.label),
    ("title", ToJson.toJson n.title),
    ("envType", ToJson.toJson n.envType),
    ("status", ToJson.toJson n.status),
    ("statementHtml", ToJson.toJson n.statementHtml),
    ("proofHtml", ToJson.toJson n.proofHtml),
    ("signatureHtml", ToJson.toJson n.signatureHtml),
    ("proofBodyHtml", ToJson.toJson n.proofBodyHtml),
    ("declNames", ToJson.toJson n.declNames),
    ("moduleName", ToJson.toJson n.moduleName),
    ("uses", ToJson.toJson n.uses),
    ("url", ToJson.toJson n.url)
  ]

instance : FromJson Node where
  fromJson? j := do
    let label ← j.getObjValAs? String "label"
    let title := (j.getObjValAs? String "title").toOption
    let envType := (j.getObjValAs? String "envType").toOption.getD "theorem"
    let status := (j.getObjValAs? String "status").toOption.getD "notReady"
    let statementHtml := (j.getObjValAs? String "statementHtml").toOption.getD ""
    let proofHtml := (j.getObjValAs? String "proofHtml").toOption
    let signatureHtml := (j.getObjValAs? String "signatureHtml").toOption
    let proofBodyHtml := (j.getObjValAs? String "proofBodyHtml").toOption
    let declNames := (j.getObjValAs? (Array String) "declNames").toOption.getD #[]
    let moduleName := (j.getObjValAs? String "moduleName").toOption.getD ""
    let uses := (j.getObjValAs? (Array String) "uses").toOption.getD #[]
    let url := (j.getObjValAs? String "url").toOption.getD ""
    pure {
      label, title, envType, status, statementHtml, proofHtml,
      signatureHtml, proofBodyHtml, declNames, moduleName, uses, url
    }

/--
Status counts from the manifest for dashboard display.
-/
structure StatusCounts where
  notReady : Nat := 0
  ready : Nat := 0
  «sorry» : Nat := 0
  proven : Nat := 0
  fullyProven : Nat := 0
  mathlibReady : Nat := 0
  deriving Repr, BEq, Inhabited, ToJson, FromJson

/--
Validation check results from graph analysis.
-/
structure CheckResults where
  /-- Whether the graph is fully connected -/
  connected : Bool := true
  /-- Number of connected components -/
  componentCount : Nat := 1
  /-- Sizes of each component -/
  componentSizes : Array Nat := #[]
  /-- Detected cycles (as arrays of labels) -/
  cycles : Array (Array String) := #[]
  deriving Repr, BEq, Inhabited, ToJson, FromJson

/--
Project notes from @[blueprint] attributes.
-/
structure ProjectNotes where
  blocked : Array (String × String) := #[]
  potentialIssues : Array (String × String) := #[]
  technicalDebt : Array (String × String) := #[]
  misc : Array (String × String) := #[]
  deriving Repr, BEq, Inhabited, ToJson, FromJson

/--
The complete manifest loaded from manifest.json.
Contains all nodes, statistics, and validation results.
-/
structure Manifest where
  /-- All blueprint nodes indexed by label -/
  nodes : Array Node := #[]
  /-- Pre-computed status counts -/
  stats : StatusCounts := {}
  /-- Graph validation results -/
  checkResults : CheckResults := {}
  /-- Key theorem labels for dashboard display -/
  keyTheorems : Array String := #[]
  /-- User messages from @[blueprint message := "..."] -/
  messages : Array (String × String) := #[]
  /-- Project notes for dashboard -/
  projectNotes : ProjectNotes := {}
  deriving Repr, BEq, Inhabited

instance : ToJson Manifest where
  toJson m := Json.mkObj [
    ("nodes", ToJson.toJson m.nodes),
    ("stats", ToJson.toJson m.stats),
    ("checkResults", ToJson.toJson m.checkResults),
    ("keyTheorems", ToJson.toJson m.keyTheorems),
    ("messages", ToJson.toJson m.messages),
    ("projectNotes", ToJson.toJson m.projectNotes)
  ]

instance : FromJson Manifest where
  fromJson? j := do
    let nodes := (j.getObjValAs? (Array Node) "nodes").toOption.getD #[]
    let stats := (j.getObjValAs? StatusCounts "stats").toOption.getD {}
    let checkResults := (j.getObjValAs? CheckResults "checkResults").toOption.getD {}
    let keyTheorems := (j.getObjValAs? (Array String) "keyTheorems").toOption.getD #[]
    let messages := (j.getObjValAs? (Array (String × String)) "messages").toOption.getD #[]
    let projectNotes := (j.getObjValAs? ProjectNotes "projectNotes").toOption.getD {}
    pure { nodes, stats, checkResults, keyTheorems, messages, projectNotes }

/--
Load a manifest from a JSON file.
-/
def Manifest.loadFromFile (path : System.FilePath) : IO Manifest := do
  let contents ← IO.FS.readFile path
  match Json.parse contents with
  | .error e => throw <| IO.userError s!"Failed to parse manifest JSON: {e}"
  | .ok json =>
    match FromJson.fromJson? json with
    | .error e => throw <| IO.userError s!"Failed to decode manifest: {e}"
    | .ok manifest => pure manifest

/--
Find a node by label in the manifest.
-/
def Manifest.findNode? (m : Manifest) (label : String) : Option Node :=
  m.nodes.find? (·.label == label)

/--
Find all nodes from a given module.
-/
def Manifest.findNodesByModule (m : Manifest) (moduleName : String) : Array Node :=
  m.nodes.filter (·.moduleName == moduleName)

/--
Get all unique module names in the manifest.
-/
def Manifest.getModuleNames (m : Manifest) : Array String :=
  m.nodes.map (·.moduleName) |>.toList.eraseDups.toArray

end VersoPaper.Manifest
